---
author: "Oliver Speer"
date: "10.12.2024"
---

::::: columns
::: {.column width="50%"}
![ ](zlm.jpeg){width=40%}
:::

::: {.column width="50%"}
```{r version number, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE}
cat("Version:\n",format(file.info("Evaluation.qmd")$mtime,"%d. %B %Y"))
```
:::
:::::

```{r, echo=FALSE, message=FALSE, warning=FALSE}
source("StartUp.R")
StartUpRoutine()
dbDisconnect(con)

```



# Evaluation {.unnumbered}

## Random Forrest I mit iFix Befund-Text-Klassifikation {.justify}
Alle Features für den EP-Chromatogramm Bereich 150-300 und Klassifikation nach iFix-Befunden
```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE}
# Daten einlesen
#EPtraining <- readRDS("EPtraining.rds")
EPvalidation <- readRDS("EPvalidation.rds")

# recipe building
rf.rec <- 
  recipe(Klassifizierung ~ ., data = EPvalidation) |>
  update_role(ID, new_role = "ID") 


# cross validation data setting
set.seed(8173)
EPfolds <- vfold_cv(EPvalidation, v = 5, repeats = 5)




# read model
final.rfI <- readRDS("final_rf.rds") |> 
  set_engine("ranger", num.threads = 2)

# workflow
rfI.wf <- workflow() |>
  add_recipe(rf.rec) |>
  add_model(final.rfI)


# start parallel processing
library(future)
plan(multisession, workers = 5)

# fit model
rfI.res <- 
  rfI.wf |> 
  fit_resamples(
    resamples = EPfolds,
    metrics = metric_set(roc_auc, accuracy, kap, sens, spec, ppv, npv, f_meas),
    control = control_resamples(save_pred = TRUE, 
                                allow_par = TRUE, 
                                save_workflow = TRUE
                                ),
    parallel_over = "resamples"
  )



plan(sequential)

saveRDS(rfI.res, "rfI_res.rds")
```

### Metriken {.justify}

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
#| label: tab-metrics-rfI
#| tbl-cap: Metriken des Random Forrest I


rfI.res <- readRDS("rfI_res.rds")
rfI.res |> 
  collect_metrics()|> 
  mutate(
    metric = .metric,
    mean = round(mean, 2),
    sd = round(std_err, 3)
  ) |> 
  select(metric, mean, n, sd) |>
  flextable()


```

### Confusion Matrix {.justify}


```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
#| label: fig-rfI-conf-mat
#| fig-cap: Confusion Matrix des Random Forrest I

#rfI.pred |> 
rfI.res |> 
  collect_predictions() |>
  conf_mat(truth = Klassifizierung, estimate = .pred_class) |> 
  autoplot(type = "heatmap")


```



## Random Forrest II mit EP Befund-Text-Klassifikation für ROC-AUC getuned {.justify}
Nur 2. Ableitungen für den EP-Chromatogramm Bereich 150-300 und Klassifikation nach EP-Befunden

```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE}
# Daten einlesen
#EPtraining <- readRDS("EPBtraining.rds")
EPvalidation <- readRDS("EPBvalidation.rds")

# recipe building
rf.rec <- 
  recipe(EPKlassifizierung ~ ., data = EPvalidation) |>
  update_role(ID, new_role = "ID") 


# cross validation data setting
set.seed(8173)
EPfolds <- vfold_cv(EPvalidation, v = 5, repeats = 5)




# read model
final.rfII <- readRDS("final_EPB_rf.rds") |> 
  set_engine("ranger", num.threads = 1
             )

# workflow
rfI.wf <- workflow() |>
  add_recipe(rf.rec) |>
  add_model(final.rfII)


# start parallel processing
library(future)
plan(multisession, workers = 10)

# fit model
rfII.res <- 
  rfI.wf |> 
  fit_resamples(
    resamples = EPfolds,
    metrics = metric_set(roc_auc, accuracy, kap, sens, spec, ppv, npv, f_meas),
    control = control_resamples(save_pred = TRUE, 
                                allow_par = TRUE, 
                                save_workflow = TRUE,
                                parallel_over = "resamples"
                                )
  )



plan(sequential)

saveRDS(rfII.res, "rfII_val_res.rds")
```

### Metriken {.justify}

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
#| label: tab-metrics-rfII
#| tbl-cap: Metriken des Random Forrest II
rfII.res <- readRDS("rfII_val_res.rds")
rfII.res |> 
  collect_metrics()|> 
  mutate(
    metric = .metric,
    mean = round(mean, 2),
    sd = round(std_err, 3)
  ) |> 
  select(metric, mean, n, sd) |>
  flextable()
```


### Confusion Matrix {.justify}



```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
#| label: fig-rfII-conf-mat
#| fig-cap: Confusion Matrix des Random Forrest II
rfII.res |> 
  collect_predictions() |> 
  conf_mat(truth = EPKlassifizierung, estimate = .pred_class) |> 
  autoplot(type = "heatmap")
```



## Random Forrest II mit EP Befund-Text-Klassifikation für NPV getuned {.justify}
Nur 2. Ableitungen für den EP-Chromatogramm Bereich 150-300 und Klassifikation nach EP-Befunden

```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE}
# Daten einlesen
#EPtraining <- readRDS("EPBtraining.rds")
EPvalidation <- readRDS("EPBvalidation.rds")

# recipe building
rf.rec <- 
  recipe(EPKlassifizierung ~ ., data = EPvalidation) |>
  update_role(ID, new_role = "ID") 


# cross validation data setting
# set.seed(8173)
# EPfolds <- vfold_cv(EPvalidation, v = 5, repeats = 5)




# read model
# final.rf.npv <- finalize_model(tune.spec, best.npv) |> 
#   set_engine("ranger", num.threads = 1)

# read model
final.rf.npv <- readRDS("final_EPB_rf_npv.rds") |> 
  set_engine("ranger", num.threads = 1)

# workflow
rfI.wf <- workflow() |>
  add_recipe(rf.rec) |>
  add_model(final.rf.npv)


# start parallel processing
library(future)
plan(multisession, workers = 10)

# fit model
rfII.npv.res <- 
  rfI.wf |> 
  fit_resamples(
    resamples = EPfolds,
    metrics = metric_set(roc_auc, accuracy, kap, sens, spec, ppv, npv, f_meas),
    control = control_resamples(save_pred = TRUE, 
                                allow_par = TRUE, 
                                save_workflow = TRUE,
                                parallel_over = "resamples"
                                )
  )



plan(sequential)

saveRDS(rfII.npv.res, "rfII_npv_res.rds")
```


```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
#| label: tab-metrics-rfII-npv
#| tbl-cap: Metriken des Random Forrest II für NPV
rfII.npv.res <- readRDS("rfII_npv_res.rds")
rfII.npv.res |> 
  collect_metrics()|> 
  mutate(
    metric = .metric,
    mean = round(mean, 2),
    sd = round(std_err, 3)
  ) |> 
  select(metric, mean, n, sd) |>
  flextable()
```


### Confusion Matrix {.justify}



```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
#| label: fig-rfII-npv-conf-mat-plot
#| fig-cap: Confusion Matrix des Random Forrest II für NPV
rfII.npv.res |> 
  collect_predictions() |>  
  conf_mat(truth = EPKlassifizierung, estimate = .pred_class) |> 
  autoplot(type = "heatmap")
```

```{r, echo=FALSE, eval=FALSE, message=FALSE, warning=FALSE}
#| label: fig-rfII-npv-roc-curve-plot
#| fig-cap: ROC Kurve des Random Forrest II für NPV
rfII.npv.res |> 
  collect_predictions() |>  
  roc_curve(truth = EPKlassifizierung, .pred_suspicous) |> 
  autoplot()
```

## Random Forrest III mit EP Befund-Text-Klassifikation für AUC getuned {.justify}
Features Steigung (m), 2. Ableitung und Fläche (AUC) für den EP-Chromatogramm Bereich 150-300 und Klassifikation nach EP-Befunden
```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE}
# Daten einlesen
#EPtraining <- readRDS("EPBtraining.rds")
EPvalidation <- readRDS("EPB_all_validation.rds")

# cross validation data setting
set.seed(8173)
EPfolds <- vfold_cv(EPvalidation, v = 5, repeats = 5)

# recipe building
rf.rec <- 
  recipe(EPKlassifizierung ~ ., data = EPvalidation) |>
  update_role(ID, new_role = "ID") 


# cross validation data setting
# set.seed(8173)
# EPfolds <- vfold_cv(EPvalidation, v = 5, repeats = 5)




# # read model
# final.rf.npv <- finalize_model(tune.spec, best.npv) |> 
#   set_engine("ranger", num.threads = 1)

# read model
final.rf.auc <- readRDS("final_EPB_all_rf.rds") |> 
  set_engine("ranger", num.threads = 1)

# workflow
rfI.wf <- workflow() |>
  add_recipe(rf.rec) |>
  add_model(final.rf.auc)


# start parallel processing
library(future)
plan(multisession, workers = 10)

# fit model
rfIII.auc.res <- 
  rfI.wf |> 
  fit_resamples(
    resamples = EPfolds,
    metrics = metric_set(roc_auc, accuracy, kap, sens, spec, ppv, npv, f_meas),
    control = control_resamples(save_pred = TRUE, 
                                allow_par = TRUE, 
                                save_workflow = TRUE,
                                parallel_over = "resamples"
                                )
  )



plan(sequential)

saveRDS(rfIII.auc.res, "rfIII_auc_res.rds")
```


```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
#| label: tab-metrics-rfIII-auc
#| tbl-cap: Metriken des Random Forrest III für AUC
rf.res <- readRDS("rfIII_auc_res.rds")
rf.res |> 
  collect_metrics()|> 
  mutate(
    metric = .metric,
    mean = round(mean, 2),
    sd = round(std_err, 3)
  ) |> 
  select(metric, mean, n, sd) |>
  flextable()
```


### Confusion Matrix {.justify}



```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
#| label: fig-rfIII-auc-conf-mat-plot
#| fig-cap: Confusion Matrix des Random Forrest III für AUC
rf.res |> 
  collect_predictions() |>  
  conf_mat(truth = EPKlassifizierung, estimate = .pred_class) |> 
  autoplot(type = "heatmap")
```


## Random Forrest III mit EP Befund-Text-Klassifikation für NPV getuned {.justify}
Features Steigung (m), 2. Ableitung und Fläche (AUC) für den EP-Chromatogramm Bereich 150-300 und Klassifikation nach EP-Befunden
```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE}
# Daten einlesen
#EPtraining <- readRDS("EPBtraining.rds")
EPvalidation <- readRDS("EPB_all_validation.rds")

# cross validation data setting
set.seed(8173)
EPfolds <- vfold_cv(EPvalidation, v = 5, repeats = 5)

# recipe building
rf.rec <- 
  recipe(EPKlassifizierung ~ ., data = EPvalidation) |>
  update_role(ID, new_role = "ID") 


# cross validation data setting
# set.seed(8173)
# EPfolds <- vfold_cv(EPvalidation, v = 5, repeats = 5)




# # read model
# final.rf.npv <- finalize_model(tune.spec, best.npv) |> 
#   set_engine("ranger", num.threads = 1)

# read model
final.rf <- readRDS("final_EPB_all_rf_npv.rds") |> 
  set_engine("ranger", num.threads = 1)

# workflow
rf.wf <- workflow() |>
  add_recipe(rf.rec) |>
  add_model(final.rf)


# start parallel processing
library(future)
plan(multisession, workers = 10)

# fit model
rf.res <- 
  rf.wf |> 
  fit_resamples(
    resamples = EPfolds,
    metrics = metric_set(roc_auc, accuracy, kap, sens, spec, ppv, npv, f_meas),
    control = control_resamples(save_pred = TRUE, 
                                allow_par = TRUE, 
                                save_workflow = TRUE,
                                parallel_over = "resamples"
                                )
  )



plan(sequential)

saveRDS(rf.res, "rfIII_npv_res.rds")
```

### Metriken {.justify}

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
#| label: tab-metrics-rfIII-npv
#| tbl-cap: Metriken des Random Forrest III für NPV
rf.res <- readRDS("rfIII_npv_res.rds")
rf.res |> 
  collect_metrics()|> 
  mutate(
    metric = .metric,
    mean = round(mean, 2),
    sd = round(std_err, 3)
  ) |> 
  select(metric, mean, n, sd) |>
  flextable()
```


### Confusion Matrix {.justify}



```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
#| label: fig-rfIII-npv-conf-mat-plot
#| fig-cap: Confusion Matrix des Random Forrest III für NPV
rf.res |> 
  collect_predictions() |>  
  conf_mat(truth = EPKlassifizierung, estimate = .pred_class) |> 
  autoplot(type = "heatmap")
```





## Random Forrest IV mit iFix gpt-Befund-Text-Klassifikation für AUC getuned {.justify}
Features: y-Signalewerte,  Steigung (m), 2. Ableitung und Fläche (AUC) für den EP-Chromatogramm Bereich 150-300 und Klassifikation der iFix-Befunden mit gpt 4o.
```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE}
# Daten einlesen
#EPtraining <- readRDS("EPBtraining.rds")
EPvalidation <- readRDS("GPT_validation.rds")

# cross validation data setting
set.seed(8173)
EPfolds <- vfold_cv(EPvalidation, v = 5, repeats = 5)

# recipe building
rf.rec <- 
  recipe(Classification ~ ., data = EPvalidation) |>
  update_role(ID, new_role = "ID") 


# cross validation data setting
# set.seed(8173)
# EPfolds <- vfold_cv(EPvalidation, v = 5, repeats = 5)




# # read model
# final.rf.npv <- finalize_model(tune.spec, best.npv) |> 
#   set_engine("ranger", num.threads = 1)

# read model
final.rf.auc <- readRDS("final_GPT_rf_auc.rds") |> 
  set_engine("ranger", num.threads = 1)

# workflow
rf.wf <- workflow() |>
  add_recipe(rf.rec) |>
  add_model(final.rf.auc)


# start parallel processing
library(future)
plan(multisession, workers = 10)

# fit model
rf.auc.res <- 
  rf.wf |> 
  fit_resamples(
    resamples = EPfolds,
    metrics = metric_set(roc_auc, accuracy, kap, sens, spec, ppv, npv, f_meas),
    control = control_resamples(save_pred = TRUE, 
                                allow_par = TRUE, 
                                save_workflow = TRUE,
                                parallel_over = "resamples"
                                )
  )



plan(sequential)

saveRDS(rf.auc.res, "rf_GPT_auc_res.rds")
```

### Metriken {.justify}

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
#| label: tab-metrics-rfIV-auc
#| tbl-cap: Metriken des Random Forrest IV für AUC
rf.res <- readRDS("rf_GPT_auc_res.rds")
rf.res |> 
  collect_metrics()|> 
  mutate(
    metric = .metric,
    mean = round(mean, 2),
    sd = round(std_err, 3)
  ) |> 
  select(metric, mean, n, sd) |>
  flextable()
```


### Confusion Matrix {.justify}



```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
#| label: fig-rfIV-auc-conf-mat-plot
#| fig-cap: Confusion Matrix des Random Forrest IV für AUC
rf.res |> 
  collect_predictions() |>  
  conf_mat(truth = Classification, estimate = .pred_class) |> 
  autoplot(type = "heatmap")
```


## Random Forrest IV mit EP Befund-Text-Klassifikation für NPV getuned {.justify}
Features Steigung (m), 2. Ableitung und Fläche (AUC) für den EP-Chromatogramm Bereich 150-300 und Klassifikation nach EP-Befunden
```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE}
# Daten einlesen
#EPtraining <- readRDS("EPBtraining.rds")
EPvalidation <- readRDS("GPT_validation.rds")

# cross validation data setting
set.seed(8173)
EPfolds <- vfold_cv(EPvalidation, v = 5, repeats = 5)

# recipe building
rf.rec <- 
  recipe(Classification ~ ., data = EPvalidation) |>
  update_role(ID, new_role = "ID") 


# cross validation data setting
# set.seed(8173)
# EPfolds <- vfold_cv(EPvalidation, v = 5, repeats = 5)




# # read model
# final.rf.npv <- finalize_model(tune.spec, best.npv) |> 
#   set_engine("ranger", num.threads = 1)

# read model
final.rf <- readRDS("final_GPT_rf_npv.rds") |> 
  set_engine("ranger", num.threads = 1)

# workflow
rf.wf <- workflow() |>
  add_recipe(rf.rec) |>
  add_model(final.rf)


# start parallel processing
library(future)
plan(multisession, workers = 10)

# fit model
rf.res <- 
  rf.wf |> 
  fit_resamples(
    resamples = EPfolds,
    metrics = metric_set(roc_auc, accuracy, kap, sens, spec, ppv, npv, f_meas),
    control = control_resamples(save_pred = TRUE, 
                                allow_par = TRUE, 
                                save_workflow = TRUE,
                                parallel_over = "resamples"
                                )
  )



plan(sequential)

saveRDS(rf.res, "rf_GPT_npv_res.rds")
```

### Metriken {.justify}

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
#| label: tab-metrics-rfIV-npv
#| tbl-cap: Metriken des Random Forrest IV für NPV
rf.res <- readRDS("rf_GPT_npv_res.rds")
rf.res |> 
  collect_metrics()|> 
  mutate(
    metric = .metric,
    mean = round(mean, 2),
    sd = round(std_err, 3)
  ) |> 
  select(metric, mean, n, sd) |>
  flextable()
```


### Confusion Matrix {.justify}



```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
#| label: fig-rfIV-npv-conf-mat-plot
#| fig-cap: Confusion Matrix des Random Forrest IV für NPV
rf.res |> 
  collect_predictions() |>  
  conf_mat(truth = Classification, estimate = .pred_class) |> 
  autoplot(type = "heatmap")
```



## Random Forrest V mit manuel bereinitgen EP-Befund-Text-Klassifikation für AUC getuned {.justify}
50 Features mit Autoencoder selektiert

```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE}
# Daten einlesen
#EPtraining <- readRDS("EPBtraining.rds")
EPvalidation <- readRDS("EP50_validation.rds")

# cross validation data setting
set.seed(8173)
EPfolds <- vfold_cv(EPvalidation, v = 5, repeats = 5)

# recipe building
rf.rec <- 
  recipe(EPKlasse ~ ., data = EPvalidation) |>
  update_role(ID, new_role = "ID") 


# cross validation data setting
# set.seed(8173)
# EPfolds <- vfold_cv(EPvalidation, v = 5, repeats = 5)




# # read model
# final.rf.npv <- finalize_model(tune.spec, best.npv) |> 
#   set_engine("ranger", num.threads = 1)

# read model
final.rf.auc <- readRDS("final_EP50_rf_auc.rds") |> 
  set_engine("ranger", num.threads = 1)

# workflow
rf.wf <- workflow() |>
  add_recipe(rf.rec) |>
  add_model(final.rf.auc)


# start parallel processing
library(future)
plan(multisession, workers = 10)

# fit model
rf.auc.res <- 
  rf.wf |> 
  fit_resamples(
    resamples = EPfolds,
    metrics = metric_set(roc_auc, accuracy, kap, sens, spec, ppv, npv, f_meas),
    control = control_resamples(save_pred = TRUE, 
                                allow_par = TRUE, 
                                save_workflow = TRUE,
                                parallel_over = "resamples"
                                )
  )



plan(sequential)

saveRDS(rf.auc.res, "rf_EP50_auc_res.rds")
```

### Metriken {.justify}

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
#| label: tab-metrics-rfV-auc
#| tbl-cap: Metriken des Random Forrest V für AUC
rf.res <- readRDS("rf_EP50_auc_res.rds")
rf.res |> 
  collect_metrics()|> 
  mutate(
    metric = .metric,
    mean = round(mean, 2),
    sd = round(std_err, 3)
  ) |> 
  select(metric, mean, n, sd) |>
  flextable()
```


### Confusion Matrix {.justify}



```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
#| label: fig-rfV-auc-conf-mat-plot
#| fig-cap: Confusion Matrix des Random Forrest IV für AUC
rf.res |> 
  collect_predictions() |>  
  conf_mat(truth = EPKlasse, estimate = .pred_class) |> 
  autoplot(type = "heatmap")
```


## Random Forrest V mit EP Befund-Text-Klassifikation nach NPV getuned {.justify}
50 autoencoder selektierte Features  und Klassifikation nach manuel bereinigten EP-Befunden
```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE}
# Daten einlesen
#EPtraining <- readRDS("EPBtraining.rds")
EPvalidation <- readRDS("EP50_validation.rds")

# cross validation data setting
set.seed(8173)
EPfolds <- vfold_cv(EPvalidation, v = 5, repeats = 5)

# recipe building
rf.rec <- 
  recipe(EPKlasse ~ ., data = EPvalidation) |>
  update_role(ID, new_role = "ID") 


# cross validation data setting
# set.seed(8173)
# EPfolds <- vfold_cv(EPvalidation, v = 5, repeats = 5)




# # read model
# final.rf.npv <- finalize_model(tune.spec, best.npv) |> 
#   set_engine("ranger", num.threads = 1)

# read model
final.rf <- readRDS("final_EP50_rf_npv.rds") |> 
  set_engine("ranger", num.threads = 1)

# workflow
rf.wf <- workflow() |>
  add_recipe(rf.rec) |>
  add_model(final.rf)


# start parallel processing
library(future)
plan(multisession, workers = 10)

# fit model
rf.res <- 
  rf.wf |> 
  fit_resamples(
    resamples = EPfolds,
    metrics = metric_set(roc_auc, accuracy, kap, sens, spec, ppv, npv, f_meas),
    control = control_resamples(save_pred = TRUE, 
                                allow_par = TRUE, 
                                save_workflow = TRUE,
                                parallel_over = "resamples"
                                )
  )



plan(sequential)

saveRDS(rf.res, "rf_EP50_npv_res.rds")
```

### Metriken {.justify}

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
#| label: tab-metrics-rfV-npv
#| tbl-cap: Metriken des Random Forrest V für NPV
rf.res <- readRDS("rf_EP50_npv_res.rds")
rf.res |> 
  collect_metrics()|> 
  mutate(
    metric = .metric,
    mean = round(mean, 2),
    sd = round(std_err, 3)
  ) |> 
  select(metric, mean, n, sd) |>
  flextable()
```


### Confusion Matrix {.justify}



```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
#| label: fig-rfV-npv-conf-mat-plot
#| fig-cap: Confusion Matrix des Random Forrest V für NPV
rf.res |> 
  collect_predictions() |>  
  conf_mat(truth = EPKlasse, estimate = .pred_class) |> 
  autoplot(type = "heatmap")
```







## Logistische Regression mit 2.Ableitungen & EP Befund-Text-Klassifikation für ROC-AUC getuned {.justify}

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
#| label: tab-metrics-log-regression-roc
#| tbl-cap: Metriken der logistischen Regression
log.res <- readRDS("log_res.rds")
log.res |> 
  collect_metrics()|> 
  mutate(
    metric = .metric,
    mean = round(mean, 2),
    sd = round(std_err, 3)
  ) |> 
  select(metric, mean, n, sd) |>
  flextable()
```


### Confusion Matrix {.justify}


```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
#| label: fig-log-conf-mat-roc
#| fig-cap: Confusion Matrix der logistischen Regression
log.res |> 
  collect_predictions() |> 
  conf_mat(truth = EPKlassifizierung, estimate = .pred_class)|> 
  autoplot(type = "heatmap")
```


## Logistische Regression mit 2.Ableitungen & EP Befund-Text-Klassifikation für ROC-AUC getuned {.justify}

```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
#| label: tab-metrics-log-regression-roc-all
#| tbl-cap: Metriken der logistischen Regression mit allen fdd-Features
log.res <- readRDS("log_res_all.rds")
log.res |> 
  collect_metrics()|> 
  mutate(
    metric = .metric,
    mean = round(mean, 2),
    sd = round(std_err, 3)
  ) |> 
  select(metric, mean, n, sd) |>
  flextable()
```


### Confusion Matrix {.justify}


```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
#| label: fig-log-conf-mat-all
#| fig-cap: Confusion Matrix der logistischen Regression
log.res |> 
  collect_predictions() |> 
  conf_mat(truth = EPKlassifizierung, estimate = .pred_class)|> 
  autoplot(type = "heatmap")
```

## Lasso Regression mit 2.Ableitungen & EP Befund-Text-Klassifikation für NPV getuned {.justify}
```{r, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE}
# Daten einlesen
EPBtraining <- readRDS("EPBtraining.rds")
EPBvalidation <- readRDS("EPBvalidation.rds")

# cross validation data set
set.seed(8173)
EPboot <- bootstraps(EPBvalidation, strata = EPKlassifizierung, times = 5)

# formula
EPB.formula <- as.formula(paste("EPKlassifizierung ~", paste(names(EPBtraining)[!(names(EPBtraining) %in% c( "EPKlassifizierung"))]
, collapse = " + ")))

EPB.formula

# recipe building
lasso.rec <- 
  recipe(EPB.formula, data = EPBtraining) |>
  update_role(ID, new_role = "ID")

# cross validation data setting
# set.seed(8173)
# EPfolds <- vfold_cv(EPvalidation, v = 5, repeats = 5)




# read model
final.lasso.m <- readRDS("final_lasso.rds") |> 
  pull_workflow_spec() |>
  set_engine("glmnet", num.threads = 1)


# workflow
lasso.wf <- workflow() |>
  add_recipe(lasso.rec) |>
  add_model(final.lasso.m)


# start parallel processing
library(future)
plan(multisession, workers = 10)

# fit model
lasso.res <- 
  lasso.wf |> 
  fit_resamples(
    resamples = EPboot,
    metrics = metric_set(roc_auc, accuracy, kap, sens, spec, ppv, npv, f_meas),
    control = control_resamples(save_pred = TRUE, 
                                save_workflow = TRUE,
                                parallel_over = "resamples"
                                )
  )



plan(sequential)

saveRDS(lasso.res, "lasso_res.rds")
```


```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
#| label: tab-metrics-lasso
#| tbl-cap: Metriken der Lasso Regression
lasso.res <- readRDS("lasso_res.rds")
lasso.res |> 
  collect_metrics()|> 
  mutate(
    metric = .metric,
    mean = round(mean, 2),
    sd = round(std_err, 3)
  ) |> 
  select(metric, mean, n, sd) |>
  head(8) |>
  flextable()
```


### Confusion Matrix {.justify}



```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
#| label: fig-lasso-conf-mat
#| fig-cap: Confusion Matrix der Lasso Regression
lasso.res |> 
  collect_predictions() |> 
  conf_mat(truth = EPKlassifizierung, estimate = .pred_class) |> 
  autoplot(type = "heatmap")
```

## Übersicht der Modelle {.justify}
```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
#| label: tab-models
#| tbl-cap: Übersicht der Modelle

#models <- c("rfI", "rfII", "rfII_npv", "rfIII", "rfIII_npv", "rfIV", "rfIV_npv", "log", "log_all", "lasso")
#metrics <- c("roc_auc", "accuracy", "kap", "sens", "spec", "ppv", "npv", "f_meas")

rfI.res <- readRDS("rfI_res.rds")
rfI.m <- rfI.res |> 
  collect_metrics(summarize = TRUE)|> 
  mutate(
    metric = .metric,
    mean = round(mean, 2),
    sd = round(std_err, 3),
    model = "rfI"
  ) #|> 
  #select(metric, mean, n, sd)

rfII.res <- readRDS("rfII_val_res.rds")
rfII.m <- rfII.res |> 
  collect_metrics()|> 
  mutate(
    metric = .metric,
    mean = round(mean, 2),
    sd = round(std_err, 3),
    model = "rfII"
  ) #|> 
  #select(metric, mean, n, sd) 

rfII.npv.res <- readRDS("rfII_npv_res.rds")
rfII.npv.m <- rfII.npv.res |> 
  collect_metrics()|> 
  mutate(
    metric = .metric,
    mean = round(mean, 2),
    sd = round(std_err, 3),
    model = "rfII_npv"
  ) #|> 
  #select(metric, mean, n, sd)


rfIII.res <- readRDS("rfIII_auc_res.rds")
rfIII.m <- rfIII.res |> 
  collect_metrics()|> 
  mutate(
    metric = .metric,
    mean = round(mean, 2),
    sd = round(std_err, 3),
    model = "rfIII"
  ) #|> 
  #select(metric, mean, n, sd)


rf.res <- readRDS("rfIII_npv_res.rds")
rfIII.npv.m <- rf.res |> 
  collect_metrics()|> 
  mutate(
    metric = .metric,
    mean = round(mean, 2),
    sd = round(std_err, 3),
    model = "rfIII_npv"
  ) #|> 
  #select(metric, mean, n, sd) 

rf.res <- readRDS("rf_GPT_auc_res.rds")
rfIV.m <- rf.res |> 
  collect_metrics()|> 
  mutate(
    metric = .metric,
    mean = round(mean, 2),
    sd = round(std_err, 3),
    model = "rfIV"
  ) #|> 
  #select(metric, mean, n, sd)

rf.res <- readRDS("rf_GPT_npv_res.rds")
rfIV.npv.m <- rf.res |> 
  collect_metrics()|> 
  mutate(
    metric = .metric,
    mean = round(mean, 2),
    sd = round(std_err, 3),
    model = "rfIV_npv"
  ) #|> 
  #select(metric, mean, n, sd)

rf.res <- readRDS("rf_EP50_auc_res.rds")
rfV.m <- rf.res |> 
  collect_metrics()|> 
  mutate(
    metric = .metric,
    mean = round(mean, 2),
    sd = round(std_err, 3),
    model = "rfV"
  ) #|> 
  #select(metric, mean, n, sd)

rf.res <- readRDS("rf_EP50_npv_res.rds")
rfV.npv.m <- rf.res |> 
  collect_metrics()|> 
  mutate(
    metric = .metric,
    mean = round(mean, 2),
    sd = round(std_err, 3),
    model = "rfV_npv"
  ) #|> 
  #select(metric, mean, n, sd)


log.res <- readRDS("log_res.rds")
log.m <- log.res |> 
  collect_metrics()|> 
  mutate(
    metric = .metric,
    mean = round(mean, 2),
    sd = round(std_err, 3),
    model = "logReg"
  ) |> 
  select(metric, mean, n, sd) 


log.res <- readRDS("log_res_all.rds")
log.all.m <- log.res |> 
  collect_metrics()|> 
  mutate(
    metric = .metric,
    mean = round(mean, 2),
    sd = round(std_err, 3),
    model = "logReg_all"
  ) #|> 
  #select(metric, mean, n, sd)


lasso.res <- readRDS("lasso_res.rds")
lasso.m <- lasso.res |> 
  collect_metrics()|> 
  mutate(
    metric = .metric,
    mean = round(mean, 2),
    sd = round(std_err, 3),
    model = "lasso"
  ) |> 
  #select(metric, mean, n, sd) |>
  head(8)

model.compare <- bind_rows(rfI.m, rfII.m, rfII.npv.m, rfIII.m, rfIII.npv.m, rfIV.m, rfIV.npv.m, rfV.m, rfV.npv.m, log.m, log.all.m, lasso.m) |> 
  select(model, metric, mean, n, sd) |> 
  pivot_wider(names_from = metric, values_from = c(mean, sd))
```


```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
#| label: tab-model-compare
#| tbl-cap: Vergleich der Modelle
model.compare |> 
  na.omit() |>
  arrange(desc(mean_npv), desc(mean_roc_auc)) |>
  flextable()
```


```{r, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
#| label: fig-model-compare
#| fig-cap: Vergleich der Modelle
model.compare |>
  na.omit() |>
  arrange(mean_roc_auc) |>
  mutate(model = fct_reorder(model, mean_roc_auc)) |>
  ggplot(aes(model, mean_roc_auc, fill=model)) +
  geom_col() +
  coord_flip() +
  #scale_fill_brewer(palette = "Blues") +
   geom_text(
     size = 3,
     aes(label = round(mean_roc_auc, 2), y = mean_roc_auc + 0.08),
     vjust = 1
              ) 

model.compare |>
  na.omit() |>
  arrange(mean_npv) |>
  mutate(model = fct_reorder(model, mean_npv)) |>
  ggplot(aes(model, mean_npv, fill=model)) +
  geom_col() +
  coord_flip() +
  #scale_fill_brewer(palette = "Blues") +
   geom_text(
     size = 3,
     aes(label = round(mean_npv, 2), y = mean_npv + 0.08),
     vjust = 1
              ) 



```

<!-- ```{r, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE} -->
<!-- ref.val.res <- readRDS("rfII_val_res.rds") -->
<!-- ref.val.res |>  -->
<!--   collect_metrics() -->
<!-- ``` -->


<!-- #### Fit und Vorhersagen mit der RFI {.justify} -->
<!-- ```{r fit-rfI, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE} -->
<!-- # Fit des finalen Modells -->
<!-- EPBvalidation <- readRDS("EPBvalidation.rds") -->
<!-- EPBtraining <- readRDS("EPBtraining.rds") -->
<!-- final.rf <- readRDS("final_rf.rds") -->

<!-- rfI.fit <- fit(final.rf, data = EPBtraining) -->

<!-- saveRDS(rfI.fit, "rfI_fit.rds") -->

<!-- # Vorhersagen -->
<!-- rfI.pred <- predict(rfI.fit, new_data = EPBvalidation, type = "prob") |>  -->
<!--    bind_cols(predict(rfI.fit, new_data = EPBvalidation, type = "class")) |> -->
<!--    bind_cols(EPBvalidation) -->
<!-- saveRDS(rfI.pred, "rfI_pred.rds") -->
<!-- ``` -->


<!-- ```{r tab-metrics-rfI-regression, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE} -->
<!-- #| label: tab-metrics-rfI-regression -->
<!-- #| tbl-cap: Metriken der rfI Regression -->

<!-- rfI.pred <- readRDS("rfI_pred.rds") -->

<!-- # Calculate metrics -->
<!-- results <- bind_rows( -->
<!--   roc_auc(data = rfI.pred, truth = EPKlassifizierung, .pred_unauffällig), -->
<!--   accuracy(data = rfI.pred, truth = EPKlassifizierung, estimate = .pred_class), -->
<!--   kap(data = rfI.pred, truth = EPKlassifizierung, estimate = .pred_class), -->
<!--   sensitivity(data = rfI.pred, truth = EPKlassifizierung, estimate = .pred_class), -->
<!--   specificity(data = rfI.pred, truth = EPKlassifizierung, estimate = .pred_class), -->
<!--   ppv(data = rfI.pred, truth = EPKlassifizierung, estimate = .pred_class), -->
<!--   npv(data = rfI.pred, truth = EPKlassifizierung, estimate = .pred_class), -->
<!--   f_meas(data = rfI.pred, truth = EPKlassifizierung, estimate = .pred_class) -->
<!-- ) |> flextable() -->
<!-- results -->
<!-- ``` -->

## Zusammenfassung & Überprüfungsprozess  {.justify}
Ständiger Konflikt Tägliche Arbeit vs Model-Entwicklung
 - zu wenig Zeit für Data-Understanding & Data-Preparation

- bisher kein Modell mit einer ROC-AUC > 0.9
- bisher kein Modell mit einer NPV > 0.9

Ich sehe noch nicht wie die vorhandenen Modelle in der Praxis eingesetzt werden können, und im Alltag einen Mehrwert und Entlastung bringen könnten.
Ich empfehle daher, die Modelle weiter zu optimieren.

** Weitere Schritte**
- Narmalisierung der Daten
- Downsampling
- Optimierung der Hyperparameter
    - Anzahl Bäume
    - Tiefe der Bäume (min_n) breiter anschauen
    - sample fraction
    - importance
    
- Mehr Daten sammeln

- Weitere Klassen einführen? (polyklonale Verstärkung, Hypogammaglobulinämie)
- EP-Befundtext mit gpt-4o klassifizieren

- XG-Boost ausprobieren

- Ensemble-Methode?





